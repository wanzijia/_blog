<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>面试题 | ZIJIA</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/logo/logo.jpg">
    <meta name="description" content="子佳的博客">
    
    <link rel="preload" href="/assets/css/0.styles.d3e1b34d.css" as="style"><link rel="preload" href="/assets/js/app.bb29d11c.js" as="script"><link rel="preload" href="/assets/js/2.571a1620.js" as="script"><link rel="preload" href="/assets/js/10.0a312df9.js" as="script"><link rel="prefetch" href="/assets/js/11.760b0bd6.js"><link rel="prefetch" href="/assets/js/12.dd0497aa.js"><link rel="prefetch" href="/assets/js/13.088063bb.js"><link rel="prefetch" href="/assets/js/14.13d23d82.js"><link rel="prefetch" href="/assets/js/15.71664f81.js"><link rel="prefetch" href="/assets/js/16.1afa945d.js"><link rel="prefetch" href="/assets/js/17.f7721fec.js"><link rel="prefetch" href="/assets/js/18.3ecfe8fa.js"><link rel="prefetch" href="/assets/js/19.5129347e.js"><link rel="prefetch" href="/assets/js/20.cdb26a80.js"><link rel="prefetch" href="/assets/js/21.860c81a0.js"><link rel="prefetch" href="/assets/js/22.b4dda94d.js"><link rel="prefetch" href="/assets/js/23.f2e5cd85.js"><link rel="prefetch" href="/assets/js/24.cbcbaa41.js"><link rel="prefetch" href="/assets/js/25.cf629994.js"><link rel="prefetch" href="/assets/js/26.c4c3a5cf.js"><link rel="prefetch" href="/assets/js/27.e32ee73a.js"><link rel="prefetch" href="/assets/js/28.34c15a66.js"><link rel="prefetch" href="/assets/js/3.065fc958.js"><link rel="prefetch" href="/assets/js/4.1338cb60.js"><link rel="prefetch" href="/assets/js/5.c0948713.js"><link rel="prefetch" href="/assets/js/6.31c0c849.js"><link rel="prefetch" href="/assets/js/7.4741cb27.js"><link rel="prefetch" href="/assets/js/8.b55d0628.js"><link rel="prefetch" href="/assets/js/9.121a3a86.js">
    <link rel="stylesheet" href="/assets/css/0.styles.d3e1b34d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">ZIJIA</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JavaScript" class="dropdown-title"><span class="title">JavaScript</span> <span class="arrow down"></span></button> <button type="button" aria-label="JavaScript" class="mobile-dropdown-title"><span class="title">JavaScript</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/js/promise/" class="nav-link">
  Promise以及事件循环机制
</a></li><li class="dropdown-item"><!----> <a href="/js/program/" class="nav-link">
  ES6
</a></li><li class="dropdown-item"><!----> <a href="/js/program/oop.html" class="nav-link">
  面向对象
</a></li><li class="dropdown-item"><!----> <a href="/js/browser/" class="nav-link">
  浏览器相关
</a></li><li class="dropdown-item"><!----> <a href="/js/apiDoc/" class="nav-link">
  api使用
</a></li></ul></div></div><div class="nav-item"><a href="/module/" class="nav-link">
  模块化
</a></div><div class="nav-item"><a href="/ts/" class="nav-link">
  TypeScript
</a></div><div class="nav-item"><a href="/engineered/" class="nav-link">
  前端工程化
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Vue相关" class="dropdown-title"><span class="title">Vue相关</span> <span class="arrow down"></span></button> <button type="button" aria-label="Vue相关" class="mobile-dropdown-title"><span class="title">Vue相关</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vue/vue2/" class="nav-link">
  Vue2
</a></li><li class="dropdown-item"><!----> <a href="/vue/vue3/" class="nav-link">
  Vue3
</a></li><li class="dropdown-item"><!----> <a href="/vue/vueRouter/" class="nav-link">
  vue-router
</a></li><li class="dropdown-item"><!----> <a href="/vue/vuex/" class="nav-link">
  vuex
</a></li><li class="dropdown-item"><!----> <a href="/vue/principle/" class="nav-link">
  Vue源码解析
</a></li></ul></div></div><div class="nav-item"><a href="/react/" class="nav-link">
  React
</a></div><div class="nav-item"><a href="/performanceOptimization/" class="nav-link">
  性能优化
</a></div><div class="nav-item"><a href="/interview/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  面试题整理
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JavaScript" class="dropdown-title"><span class="title">JavaScript</span> <span class="arrow down"></span></button> <button type="button" aria-label="JavaScript" class="mobile-dropdown-title"><span class="title">JavaScript</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/js/promise/" class="nav-link">
  Promise以及事件循环机制
</a></li><li class="dropdown-item"><!----> <a href="/js/program/" class="nav-link">
  ES6
</a></li><li class="dropdown-item"><!----> <a href="/js/program/oop.html" class="nav-link">
  面向对象
</a></li><li class="dropdown-item"><!----> <a href="/js/browser/" class="nav-link">
  浏览器相关
</a></li><li class="dropdown-item"><!----> <a href="/js/apiDoc/" class="nav-link">
  api使用
</a></li></ul></div></div><div class="nav-item"><a href="/module/" class="nav-link">
  模块化
</a></div><div class="nav-item"><a href="/ts/" class="nav-link">
  TypeScript
</a></div><div class="nav-item"><a href="/engineered/" class="nav-link">
  前端工程化
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Vue相关" class="dropdown-title"><span class="title">Vue相关</span> <span class="arrow down"></span></button> <button type="button" aria-label="Vue相关" class="mobile-dropdown-title"><span class="title">Vue相关</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vue/vue2/" class="nav-link">
  Vue2
</a></li><li class="dropdown-item"><!----> <a href="/vue/vue3/" class="nav-link">
  Vue3
</a></li><li class="dropdown-item"><!----> <a href="/vue/vueRouter/" class="nav-link">
  vue-router
</a></li><li class="dropdown-item"><!----> <a href="/vue/vuex/" class="nav-link">
  vuex
</a></li><li class="dropdown-item"><!----> <a href="/vue/principle/" class="nav-link">
  Vue源码解析
</a></li></ul></div></div><div class="nav-item"><a href="/react/" class="nav-link">
  React
</a></div><div class="nav-item"><a href="/performanceOptimization/" class="nav-link">
  性能优化
</a></div><div class="nav-item"><a href="/interview/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  面试题整理
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/interview/" aria-current="page" class="active sidebar-link">面试题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview/#框架相关" class="sidebar-link">框架相关</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview/#vue-router" class="sidebar-link">vue-router</a></li><li class="sidebar-sub-header"><a href="/interview/#vue2-和-vue3" class="sidebar-link">vue2 和 vue3</a></li><li class="sidebar-sub-header"><a href="/interview/#react-和-vue" class="sidebar-link">react 和 vue</a></li></ul></li><li class="sidebar-sub-header"><a href="/interview/#css相关" class="sidebar-link">css相关</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview/#说一下-css-盒模型" class="sidebar-link">说一下 css 盒模型</a></li><li class="sidebar-sub-header"><a href="/interview/#画一条-0-5px-的线" class="sidebar-link">画一条 0.5px 的线</a></li><li class="sidebar-sub-header"><a href="/interview/#link标签和-import的区别" class="sidebar-link">link标签和@import的区别</a></li><li class="sidebar-sub-header"><a href="/interview/#transition-和-animation-的区别" class="sidebar-link">transition 和 animation 的区别</a></li><li class="sidebar-sub-header"><a href="/interview/#flex-布局" class="sidebar-link">Flex 布局</a></li><li class="sidebar-sub-header"><a href="/interview/#bfc" class="sidebar-link">BFC</a></li><li class="sidebar-sub-header"><a href="/interview/#子元素如何在父元素中居中" class="sidebar-link">子元素如何在父元素中居中</a></li><li class="sidebar-sub-header"><a href="/interview/#如何让-chrome-浏览器显示小于-12px-的文字" class="sidebar-link">如何让 chrome 浏览器显示小于 12px 的文字</a></li><li class="sidebar-sub-header"><a href="/interview/#多行元素的文本省略号" class="sidebar-link">多行元素的文本省略号</a></li><li class="sidebar-sub-header"><a href="/interview/#css3-新特性" class="sidebar-link">css3 新特性</a></li><li class="sidebar-sub-header"><a href="/interview/#css-选择器有哪些" class="sidebar-link">CSS 选择器有哪些</a></li><li class="sidebar-sub-header"><a href="/interview/#css-画正方体-三角形" class="sidebar-link">CSS 画正方体，三角形</a></li><li class="sidebar-sub-header"><a href="/interview/#重绘与回流" class="sidebar-link">重绘与回流</a></li></ul></li><li class="sidebar-sub-header"><a href="/interview/#js相关" class="sidebar-link">js相关</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview/#get-post的区别" class="sidebar-link">get/post的区别</a></li><li class="sidebar-sub-header"><a href="/interview/#闭包" class="sidebar-link">闭包</a></li><li class="sidebar-sub-header"><a href="/interview/#js-中的垃圾回收机制" class="sidebar-link">JS 中的垃圾回收机制</a></li><li class="sidebar-sub-header"><a href="/interview/#构造函数继承的几种方式" class="sidebar-link">构造函数继承的几种方式</a></li><li class="sidebar-sub-header"><a href="/interview/#如何解决异步回调地狱" class="sidebar-link">如何解决异步回调地狱</a></li><li class="sidebar-sub-header"><a href="/interview/#说说前端中的事件流" class="sidebar-link">说说前端中的事件流</a></li><li class="sidebar-sub-header"><a href="/interview/#说一下事件委托" class="sidebar-link">说一下事件委托</a></li><li class="sidebar-sub-header"><a href="/interview/#说一下图片的懒加载和预加载" class="sidebar-link">说一下图片的懒加载和预加载</a></li><li class="sidebar-sub-header"><a href="/interview/#js-的-new-操作符做了哪些事情" class="sidebar-link">JS 的 new 操作符做了哪些事情</a></li><li class="sidebar-sub-header"><a href="/interview/#bind-apply-call-的区别" class="sidebar-link">bind，apply，call 的区别</a></li><li class="sidebar-sub-header"><a href="/interview/#clientheight-scrollheight-offsetheight-以及-scrolltop-offsettop-clienttop-的区别" class="sidebar-link">clientHeight,scrollHeight,offsetHeight ,以及 scrollTop, offsetTop,clientTop 的区别？</a></li><li class="sidebar-sub-header"><a href="/interview/#异步加载-js-的方法" class="sidebar-link">异步加载 JS 的方法</a></li><li class="sidebar-sub-header"><a href="/interview/#ajax-解决浏览器缓存问题" class="sidebar-link">Ajax 解决浏览器缓存问题</a></li><li class="sidebar-sub-header"><a href="/interview/#js-的节流和防抖" class="sidebar-link">JS 的节流和防抖</a></li><li class="sidebar-sub-header"><a href="/interview/#对象深度克隆的简单实现" class="sidebar-link">对象深度克隆的简单实现</a></li><li class="sidebar-sub-header"><a href="/interview/#实现一个-once-函数-传入函数参数只执行一次" class="sidebar-link">实现一个 once 函数，传入函数参数只执行一次</a></li><li class="sidebar-sub-header"><a href="/interview/#settimeout、setinterval-和-requestanimationframe-之间的区别" class="sidebar-link">setTimeout、setInterval 和 requestAnimationFrame 之间的区别</a></li><li class="sidebar-sub-header"><a href="/interview/#用-settimeout-来实现-setinterval" class="sidebar-link">用 setTimeout 来实现 setInterval</a></li><li class="sidebar-sub-header"><a href="/interview/#js-怎么控制一次加载一张图片-加载完后再加载下一张" class="sidebar-link">JS 怎么控制一次加载一张图片，加载完后再加载下一张</a></li><li class="sidebar-sub-header"><a href="/interview/#代码的执行顺序" class="sidebar-link">代码的执行顺序</a></li><li class="sidebar-sub-header"><a href="/interview/#js-判断类型" class="sidebar-link">JS 判断类型</a></li><li class="sidebar-sub-header"><a href="/interview/#数组去重" class="sidebar-link">数组去重</a></li><li class="sidebar-sub-header"><a href="/interview/#手写实现api部分" class="sidebar-link">手写实现api部分</a></li><li class="sidebar-sub-header"><a href="/interview/#知道-private-和-public-吗" class="sidebar-link">知道 private 和 public 吗</a></li><li class="sidebar-sub-header"><a href="/interview/#es6-的常用" class="sidebar-link">es6 的常用</a></li><li class="sidebar-sub-header"><a href="/interview/#eventloop" class="sidebar-link">EventLoop</a></li></ul></li><li class="sidebar-sub-header"><a href="/interview/#服务端-浏览器" class="sidebar-link">服务端&amp;浏览器</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview/#什么是跨域-为什么浏览器要使用同源策略-你有几种方式可以解决跨域问题-了解预检请求嘛" class="sidebar-link">什么是跨域？为什么浏览器要使用同源策略？你有几种方式可以解决跨域问题？了解预检请求嘛？</a></li><li class="sidebar-sub-header"><a href="/interview/#http和https" class="sidebar-link">http和https</a></li><li class="sidebar-sub-header"><a href="/interview/#从输入url到获取页面过程" class="sidebar-link">从输入url到获取页面过程</a></li></ul></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="面试题"><a href="#面试题" class="header-anchor">#</a> 面试题</h1> <h2 id="框架相关"><a href="#框架相关" class="header-anchor">#</a> 框架相关</h2> <h3 id="vue-router"><a href="#vue-router" class="header-anchor">#</a> vue-router</h3> <h4 id="vue-router有关"><a href="#vue-router有关" class="header-anchor">#</a> vue-router有关</h4> <ol><li><p>hash 路由 和 history 路由，有什么区别</p> <ul><li>hash 路由 一般会携带 一个 # 号，不够美观； history 路由不存在这个问题；</li> <li>默认 hash 路由是不会像浏览器发出请求的，主要是一般用于锚点；history 中 go /back / forward 以及浏览器的前进、后退按钮一般都会像服务端发起请求；-- history 的所有 url 内容，服务端都可以获取到</li> <li>基于此，hash 模式，是不支持SSR的，但是 history 模式可以做 SSR</li> <li>history 在部署的时候，如 nginx， 需要只渲染首⻚，让首⻚根据路径重新跳转</li> <li>hash路由的监听，一般用onHashChange; history路由的监听，一般用onPopState</li> <li>要注意：如何部署</li></ul></li></ol> <div class="language-Nginx extra-class"><pre class="language-nginx"><code><span class="token comment"># 单个的服务器部署</span>
<span class="token directive"><span class="token keyword">location</span> /</span> <span class="token punctuation">{</span>
    try_files uri $uri /xxx/main/index.html
<span class="token punctuation">}</span>

<span class="token comment"># 存在代理的情况</span>
<span class="token directive"><span class="token keyword">location</span> /</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">rewrite</span> ^ /file/index.html break</span><span class="token punctuation">;</span> <span class="token comment"># 这里代表的是xxx.cdn 的资源路径</span>
    <span class="token directive"><span class="token keyword">proxy_pass</span> https://www.xxx.cdn.com</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="2"><li>history.go / back 一定会刷新吗</li></ol> <p>要根据指定⻚面和当前界面的构建关系，动态决定</p> <ol start="3"><li>pushState 会触发 popState 事件吗？
popState 是监听其他的操作。</li></ol> <ul><li>pushState/replaceState 都不会触发 popState 事件，需要触发⻚面的重新渲染。</li> <li>popState 什么时候触发？
<ul><li>点击浏览器的前进、后退按钮</li> <li>back / forward / go</li></ul></li></ul> <h3 id="vue2-和-vue3"><a href="#vue2-和-vue3" class="header-anchor">#</a> vue2 和 vue3</h3> <h4 id="从-vue2-到-vue3-有哪些升级更新-非兼容的变更"><a href="#从-vue2-到-vue3-有哪些升级更新-非兼容的变更" class="header-anchor">#</a> 从 vue2 到 vue3 有哪些升级更新（非兼容的变更）</h4> <h4 id="底层数据劫持的区别-从defineproperty到proxy"><a href="#底层数据劫持的区别-从defineproperty到proxy" class="header-anchor">#</a> 底层数据劫持的区别，从defineproperty到proxy</h4> <h4 id="组件形态上的变化"><a href="#组件形态上的变化" class="header-anchor">#</a> 组件形态上的变化</h4> <h4 id="组合api的优势"><a href="#组合api的优势" class="header-anchor">#</a> 组合api的优势</h4> <h4 id="vue2中vue3"><a href="#vue2中vue3" class="header-anchor">#</a> vue2中vue3</h4> <h4 id="vue3源码-diff算法你了解吗"><a href="#vue3源码-diff算法你了解吗" class="header-anchor">#</a> vue3源码 diff算法你了解吗</h4> <p><a href="https://zhuanlan.zhihu.com/p/421197879" target="_blank" rel="noopener noreferrer">v2和v3 diff算法的区别<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="react-和-vue"><a href="#react-和-vue" class="header-anchor">#</a> react 和 vue</h3> <h4 id="hooks有什么区别"><a href="#hooks有什么区别" class="header-anchor">#</a> hooks有什么区别</h4> <h4 id="生命周期"><a href="#生命周期" class="header-anchor">#</a> 生命周期</h4> <h4 id="路由"><a href="#路由" class="header-anchor">#</a> 路由</h4> <h4 id="更新的方法机制"><a href="#更新的方法机制" class="header-anchor">#</a> 更新的方法机制</h4> <h4 id="状态管理库-redux和vuex"><a href="#状态管理库-redux和vuex" class="header-anchor">#</a> 状态管理库（redux和vuex）</h4> <h2 id="css相关"><a href="#css相关" class="header-anchor">#</a> css相关</h2> <h3 id="说一下-css-盒模型"><a href="#说一下-css-盒模型" class="header-anchor">#</a> 说一下 css 盒模型</h3> <p>CSS 中的盒子模型包括 IE 盒子模型和标准的 W3C 盒子模型
box-sizing(有 3 个值哦)：border-box,padding-box,content-box
区别：这两种盒子模型最主要的区别就是 width 的包含范围，在标准的盒子模型中，width 指 content 部分的宽度，在 IE 盒子模型中，width 表示 content+padding+border 这三个部分的宽度，故这使得在计算整个盒子的宽度时存在着差异：</p> <ul><li>标准盒子模型的盒子宽度：左右 border+左右 padding+width IE 盒子模型的盒子宽度：width</li></ul> <h3 id="画一条-0-5px-的线"><a href="#画一条-0-5px-的线" class="header-anchor">#</a> 画一条 0.5px 的线</h3> <ol><li><p>利用meta标签
//当 devicePixelRatio = 2 输出：
</p><meta name="viewport" content="initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no">
//当 devicePixelRatio = 3 输出：
<meta name="viewport" content="initial-scale=0.3333333333333333, maximum-scale=0.3333333333333333, minimum-scale=0.3333333333333333, user-scalable=no">
缺点：Mobile APP 在设计上会存在问题<p></p></li> <li><p>采用 border-image 的方式</p></li> <li><p>设置线条为1px，然后通过transform:scale(x,y)来缩放线条为原来的一半，可显示0.5px的线条。</p></li></ol> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.scale:after</span> <span class="token punctuation">{</span>
    <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
    <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">;</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
    <span class="token property">left</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
    <span class="token property">bottom</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 1px<span class="token punctuation">;</span>
    <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
    <span class="token property">-webkit-transform</span><span class="token punctuation">:</span> <span class="token function">scale</span><span class="token punctuation">(</span>1<span class="token punctuation">,</span>.5<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">scale</span><span class="token punctuation">(</span>1<span class="token punctuation">,</span>.5<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token property">-webkit-transform-origin</span><span class="token punctuation">:</span> center bottom<span class="token punctuation">;</span>
    <span class="token property">transform-origin</span><span class="token punctuation">:</span> center bottom
<span class="token punctuation">}</span>
    <span class="token comment">/* 定义0.5的圆角边框 */</span>
    <span class="token selector">.btn</span> <span class="token punctuation">{</span>
        <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
        <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
        <span class="token property">height</span><span class="token punctuation">:</span> 42px<span class="token punctuation">;</span>
        <span class="token property">-webkit-border-radius</span><span class="token punctuation">:</span> 5px<span class="token punctuation">;</span>
        <span class="token property">border-radius</span><span class="token punctuation">:</span> 5px<span class="token punctuation">;</span>
        <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
        <span class="token property">line-height</span><span class="token punctuation">:</span> 42px<span class="token punctuation">;</span>
        <span class="token property">background-color</span><span class="token punctuation">:</span> #EDEDED<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token selector">.btn:before</span> <span class="token punctuation">{</span>
        <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">;</span>
        <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
        <span class="token property">top</span><span class="token punctuation">:</span> -50%<span class="token punctuation">;</span>
        <span class="token property">bottom</span><span class="token punctuation">:</span> -50%<span class="token punctuation">;</span>
        <span class="token property">left</span><span class="token punctuation">:</span> -50%<span class="token punctuation">;</span>
        <span class="token property">right</span><span class="token punctuation">:</span> -50%<span class="token punctuation">;</span>
        <span class="token property">-webkit-transform</span><span class="token punctuation">:</span> <span class="token function">scale</span><span class="token punctuation">(</span>0.5<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">scale</span><span class="token punctuation">(</span>0.5<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token property">border-style</span><span class="token punctuation">:</span> solid<span class="token punctuation">;</span>
        <span class="token property">border-width</span><span class="token punctuation">:</span> 1px<span class="token punctuation">;</span>
        <span class="token property">border-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
        <span class="token property">-webkit-border-radius</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>
        <span class="token property">border-radius</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

</code></pre></div><h3 id="link标签和-import的区别"><a href="#link标签和-import的区别" class="header-anchor">#</a> link标签和@import的区别</h3> <p>link属于html标签 @import是css提供的<br>
页面被加载时 link会同时加载 而@import引用的css会等到页面加载结束后加载，可能会有一瞬间的样式闪烁
link是html标签 没有兼容性的问题  @import需要ie5以上 link权重 &gt; @import</p> <h3 id="transition-和-animation-的区别"><a href="#transition-和-animation-的区别" class="header-anchor">#</a> transition 和 animation 的区别</h3> <p>主要区别是 transition 需要触发一个事件才能改变属性，而 animation 不需要触发任何 事件的情况下才会随时间改变属性值，并且 transition 为 2 帧，从 from .... to，而 animation 可以一帧一帧的</p> <h3 id="flex-布局"><a href="#flex-布局" class="header-anchor">#</a> Flex 布局</h3> <p>简单的分为容器属性和元素属性</p> <ol><li>容器的属性：</li></ol> <div class="language-css extra-class"><pre class="language-css"><code><span class="token comment">/* flex-direction：决定主轴的方向（即子 item 的排列方法）  */</span>
<span class="token selector">.box</span> <span class="token punctuation">{</span> <span class="token property">flex-direction</span><span class="token punctuation">:</span> row | row-reverse | column | column-reverse<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token comment">/* flex-wrap：决定换行规则  */</span>
<span class="token selector">.box</span><span class="token punctuation">{</span> <span class="token property">flex-wrap</span><span class="token punctuation">:</span> nowrap | wrap | wrap-reverse<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token comment">/* flex-flow：  */</span>
<span class="token selector">.box</span> <span class="token punctuation">{</span> <span class="token property">flex-flow</span><span class="token punctuation">:</span> &lt;flex-direction&gt; || &lt;flex-wrap&gt;<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token comment">/* justify-content：对其方式，水平主轴对齐方式  */</span>
<span class="token comment">/* align-items：对齐方式，竖直轴线方向 */</span>
</code></pre></div><ol start="2"><li>元素的属性</li></ol> <ul><li>order 属性：定义项目的排列顺序，顺序越小，排列越靠前，默认为 0</li> <li>flex-grow 属性：定义项目的放大比例，即使存在空间，也不会放大</li> <li>flex-shrink 属性：定义了项目的缩小比例，当空间不足的情况下会等比例的缩小，如果 定义个item 的 flow-shrink 为 0，则为不缩小</li> <li>flex-basis 属性：定义了在分配多余的空间，项目占据的空间</li> <li>flex：是 flex-grow 和 flex-shrink、flex-basis 的简写，默认值为 0 1 auto。</li> <li>align-self：允许单个项目与其他项目不一样的对齐方式，可以覆盖 align-items，默认属 性为 auto，表示继承父元素的 align-items</li></ul> <h3 id="bfc"><a href="#bfc" class="header-anchor">#</a> BFC</h3> <p>块级格式化上下文，是一个独立的渲染区域，并且有一定的布局规则</p> <ol><li>BFC 区域不会与 float box 重叠</li> <li>BFC 是页面上的一个独立容器，子元素不会影响到外面</li> <li>计算 BFC 的高度时，浮动元素也会参与计算</li></ol> <p>哪些元素会生成 BFC：
根元素 float 不为 none 的元素<br>
position 为 fixed 和 absolute 的元素<br>
display 为 inline-block、table-cell、table-caption，flex，inline-flex 的元素<br>
overflow 不为 visible 的元素</p> <h3 id="子元素如何在父元素中居中"><a href="#子元素如何在父元素中居中" class="header-anchor">#</a> 子元素如何在父元素中居中</h3> <p>水平居中：
父子元素宽度固定 margin：auto / 父元素设置 text-align：center，子元素设置display：inline-block，</p> <p>垂直居中：</p> <ul><li>设置子元素和父元素的行高一样</li> <li>子元素设置为行内块，再加 vertical-align：middle(该属性定义行内元素的基线相对于该元素所在行的基线的垂直对齐.如果a和b都加了一个vertical-align:middle样式，那么就互相对齐了对方的中间位置，也就是它们在垂直方向上的中线对齐了)</li> <li>创建一个隐藏节点，让隐藏节点的 height 为剩余高度的一半</li> <li>给父元素 display：table，子元素 display：table-cell，vertical-align： middle;</li> <li>弹性盒，父元素 display：flex，子元素 align-self：center</li></ul> <p>水平垂直居中：</p> <ul><li>子元素position absolute 子元素top left 50% margin-left 负宽度一半 margin-top 负高度一半</li> <li>子元素相对父元素绝对定位，子元素 top，left 值为 50%，transform： translate（-50%，-50%）</li> <li>子元素position absolute 上下左右全设为 0 子元素 margin： auto；</li> <li>弹性盒子 display：flex； justfy-content：center ；align-item：center； justfy-content：center</li></ul> <h3 id="如何让-chrome-浏览器显示小于-12px-的文字"><a href="#如何让-chrome-浏览器显示小于-12px-的文字" class="header-anchor">#</a> 如何让 chrome 浏览器显示小于 12px 的文字</h3> <ul><li>-webkit-text-size-adjust ： none</li> <li>-webkit-transform：scale（）</li></ul> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.content</span><span class="token punctuation">{</span>
    <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">scale</span><span class="token punctuation">(</span>.5<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 200%<span class="token punctuation">;</span>
    <span class="token property">transform-origin</span><span class="token punctuation">:</span>0 0 <span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre></div><h3 id="多行元素的文本省略号"><a href="#多行元素的文本省略号" class="header-anchor">#</a> 多行元素的文本省略号</h3> <p>display: -webkit-box
-webkit-box-orient:vertical
-webkit-line-clamp:3
overflow:hidden</p> <h3 id="css3-新特性"><a href="#css3-新特性" class="header-anchor">#</a> css3 新特性</h3> <ul><li>CSS3 边框如 border-radius，box-shadow 等；</li> <li>CSS3 背景如 background-size， background-origin 等；</li> <li>CSS3 2D，3D 转换如 transform 等；</li> <li>CSS3 动画如 animation 等。</li></ul> <h3 id="css-选择器有哪些"><a href="#css-选择器有哪些" class="header-anchor">#</a> CSS 选择器有哪些</h3> <p>id 选择器，class 选择器，标签选择器，伪元素选择器，伪类选择器</p> <table><thead><tr><th>选择器</th> <th>格式</th> <th>优先级权重</th></tr></thead> <tbody><tr><td>id选择器</td> <td>#id</td> <td>100</td></tr> <tr><td>类选择器</td> <td>.classname</td> <td>10</td></tr> <tr><td>属性选择器</td> <td>a[ref=“eee”]</td> <td>10</td></tr> <tr><td>伪类选择器</td> <td>li:last-child 或 a:hover</td> <td>10</td></tr> <tr><td>标签选择器</td> <td>div</td> <td>0</td></tr> <tr><td>伪元素选择器</td> <td>li::after</td> <td>0</td></tr> <tr><td>相邻兄弟选择器</td> <td>h1+p</td> <td>0</td></tr> <tr><td>子选择器</td> <td>ul&gt;li</td> <td>0</td></tr> <tr><td>后代选择器</td> <td>li a</td> <td>0</td></tr> <tr><td>通配符选择器</td> <td>*</td> <td>0</td></tr></tbody></table> <h3 id="css-画正方体-三角形"><a href="#css-画正方体-三角形" class="header-anchor">#</a> CSS 画正方体，三角形</h3> <div class="language-css extra-class"><pre class="language-css"><code><span class="token comment">/* 三角形 */</span>
<span class="token selector">#triangle02</span><span class="token punctuation">{</span> 
    <span class="token property">width</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span> 
    <span class="token property">height</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span> 
    <span class="token property">border-top</span><span class="token punctuation">:</span> 50px solid blue<span class="token punctuation">;</span> 
    <span class="token property">border-right</span><span class="token punctuation">:</span> 50px solid red<span class="token punctuation">;</span> 
    <span class="token property">border-bottom</span><span class="token punctuation">:</span> 50px solid green<span class="token punctuation">;</span> 
    <span class="token property">border-left</span><span class="token punctuation">:</span> 50px solid yellow<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre></div><h3 id="重绘与回流"><a href="#重绘与回流" class="header-anchor">#</a> 重绘与回流</h3> <blockquote><p>当元素的样式发生变化时，浏览器需要触发更新，重新绘制元素。这个过程中，有两种类型的操作，即重绘与回流。</p></blockquote> <blockquote><ul><li>重绘(repaint): 当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此 损耗较少</li> <li>回流(reflow): 当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。会触发回流的操作:</li></ul></blockquote> <ul><li>页面初次渲染</li> <li>浏览器窗口大小改变</li> <li>元素尺寸、位置、内容发生改变</li> <li>元素字体大小变化</li> <li>添加或者删除可见的 <code>dom</code> 元素</li> <li>激活 <code>CSS</code> 伪类（例如：<code>:hover</code>）</li> <li>查询某些属性或调用某些方法
<ul><li><code>clientWidth、clientHeight、clientTop、clientLeft</code></li> <li><code>offsetWidth、offsetHeight、offsetTop、offsetLeft</code></li> <li><code>scrollWidth、scrollHeight、scrollTop、scrollLeft</code></li> <li><code>getComputedStyle()</code></li> <li><code>getBoundingClientRect()</code></li> <li><code>scrollTo()</code></li></ul></li></ul> <blockquote><p>回流必定触发重绘，重绘不一定触发回流。重绘的开销较小，回流的代价较高。</p></blockquote> <p><strong>最佳实践:</strong></p> <p><strong>css</strong></p> <ul><li>避免使用<code>table</code>布局</li> <li>将动画效果应用到<code>position</code>属性为<code>absolute</code>或<code>fixed</code>的元素上</li></ul> <p><strong>javascript</strong></p> <ul><li>避免频繁操作样式，可汇总后统一 一次修改</li> <li>尽量使用<code>class</code>进行样式修改</li> <li>减少<code>dom</code>的增删次数，可使用 字符串 或者 <code>documentFragment</code> 一次性插入</li> <li>极限优化时，修改样式可将其<code>display: none</code>后修改</li> <li>避免多次触发上面提到的那些会触发回流的方法，可以的话尽量用 变量存住</li></ul> <p>如何减少</p> <p>如果想设定元素的样式，通过改变元素的 class 类名 (尽可能在 DOM 树的最里层)避免设置多项内联样式<br>
应用元素的动画，使用 position 属性的 fixed 值或 absolute 值(如前文示例所提)<br>
避免使用 table 布局，table 中每个元素的大小以及内容的改动，都会导致整个 table 的重新计算<br>
对于那些复杂的动画，对其设置 position: fixed/absolute，尽可能地使元素脱离文档流，从而减少对其他元素的影响<br>
使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘
避免使用 CSS 的 JavaScript 表达式</p> <h2 id="js相关"><a href="#js相关" class="header-anchor">#</a> js相关</h2> <h3 id="get-post的区别"><a href="#get-post的区别" class="header-anchor">#</a> get/post的区别</h3> <p>HTTP 协议 未规定 GET 和 POST 的长度限制 GET 的最大长度显示是因为 浏览器和 web 服务器限制了 URI 的长度</p> <ol><li>get数据是存放在url之后，以？分割url和传输数据，参数之间以&amp;相连； post方法是把提交的数据放在http包的Body中</li> <li>get提交的数据大小有限制，（因为浏览器对url的长度有限制），post的方法提交的数据没有限制</li> <li>get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量的值</li> <li>get的方法提交数据，会带来安全问题，比如登录一个页面，通过get的方式提交数据，用户名和密码就会出现在url上</li></ol> <h3 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h3> <p>闭包指的是一个环境，利用作用域的嵌套，使内部作用域可以访问外部变量 函数嵌套函数 ，内部获取到的函数变量不会被垃圾回收机制回收   可能会造成内存泄露</p> <h4 id="常见的内存泄露"><a href="#常见的内存泄露" class="header-anchor">#</a> 常见的内存泄露</h4> <ol><li>意外的全局变量<br>
当我们在一个函数中给一个变量赋值，但是没有声明它时
全局变量很难被垃圾回收器回收，所以会进行内存泄露。</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	a <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="2"><li>被遗忘的定时器</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> serverData <span class="token operator">=</span> <span class="token function">loadData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
setIntervalDemo <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
	<span class="token keyword">var</span> renderer <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getItemById</span><span class="token punctuation">(</span><span class="token string">'renderer'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
	<span class="token keyword">if</span><span class="token punctuation">(</span>renderer<span class="token punctuation">)</span><span class="token punctuation">{</span>  
		render<span class="token punctuation">.</span>InnerHTML <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>serverData<span class="token punctuation">)</span>  
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">5000</span><span class="token punctuation">)</span>  
</code></pre></div><ol start="3"><li>时间的监听<br>
一旦他们不再需要（或者关联的对象变成不可达），明确的移除他们非常必要。因为他要一直阻塞在那里监听，浪费内存。</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> btn <span class="token operator">-</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'btn'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token keyword">function</span> <span class="token function">onClick</span><span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
	element<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">'I`m innerHTML'</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>  
btn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span>onClick<span class="token punctuation">)</span><span class="token punctuation">;</span>  
</code></pre></div><ol start="4"><li>脱离 DOM 的引用<br>
如果把DOM存成字典（JSON键值对）或者数组，此时同样的DOM元素存在两个引用：
<ul><li>一个在DOM树中</li> <li>另一个在字典中<br>
那么两个都需要删除</li></ul></li></ol> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token keyword">var</span> elements <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">btn</span><span class="token operator">:</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'btn'</span><span class="token punctuation">)</span><span class="token punctuation">}</span>  
    <span class="token keyword">function</span> <span class="token function">doSomeThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        elements<span class="token punctuation">.</span>btn<span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token keyword">function</span> <span class="token function">removeBtn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token comment">//将body中的btn移除，也就是移除DOM树中的btn  </span>
        document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token comment">//但是此时全局变量elements还是保留了btn的引用，并且还赋值给了这个字典，这个 DOM元素还是在内存中，不能回收。  </span>
    <span class="token punctuation">}</span>  
</code></pre></div><h3 id="js-中的垃圾回收机制"><a href="#js-中的垃圾回收机制" class="header-anchor">#</a> JS 中的垃圾回收机制</h3> <p>由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他 们进行动态的存储分配。JavaScript 程序每次创建字符串、数组或对象时，解释器都必 须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以 便他们能够被再用，否则，JavaScript 的解释器将会消耗完系统中所有可用的内存，造 成系统崩溃</p> <h3 id="构造函数继承的几种方式"><a href="#构造函数继承的几种方式" class="header-anchor">#</a> 构造函数继承的几种方式</h3> <p><a href="http://wanzijia.co/js/program/oop.html#%E7%BB%A7%E6%89%BF" target="_blank" rel="noopener noreferrer">继承<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ol><li>原型链继承，将父类的实例作为子类的原型，他的特点是实例是子类的实例也是父 类的实例，父类新增的原型方法/属性，子类都能够访问，并且原型链继承简单易于实 现，缺点是来自原型对象的所有属性被所有实例共享，无法实现多继承，无法向父类构 造函数传参。</li> <li>构造继承，使用父类的构造函数来增强子类实例，即复制父类的实例属性给子类， 构造继承可以向父类传递参数，可以实现多继承，通过 call 多个父类对象。但是构造继 承只能继承父类的实例属性和方法，不能继承原型属性和方法，无法实现函数服用，每 个子类都有父类实例函数的副本，影响性能</li> <li>实例继承，为父类实例添加新特性，作为子类实例返回，实例继承的特点是不限制 调用方法，不管是 new 子类（）还是子类（）返回的对象具有相同的效果，缺点是实 例是父类的实例，不是子类的实例，不支持多继承</li> <li>拷贝继承：特点：支持多继承，缺点：效率较低，内存占用高（因为要拷贝父类的 属性）无法获取父类不可枚举的方法（不可枚举方法，不能使用 for in 访问到）</li> <li>组合继承：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父 类实例作为子类原型，实现函数复用</li> <li>寄生组合继承：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构 造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点</li></ol> <h3 id="如何解决异步回调地狱"><a href="#如何解决异步回调地狱" class="header-anchor">#</a> 如何解决异步回调地狱</h3> <p>promise、generator、async/await</p> <h3 id="说说前端中的事件流"><a href="#说说前端中的事件流" class="header-anchor">#</a> 说说前端中的事件流</h3> <p>事件捕获阶段 处于目标阶段 事件冒泡阶段</p> <h3 id="说一下事件委托"><a href="#说一下事件委托" class="header-anchor">#</a> 说一下事件委托</h3> <p>事件委托指的是，不在事件的发生地（直接 dom）上设置监听函数，而是在其父 元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判 断事件发生元素 DOM 的类型，来做出不同的响应</p> <p>好处：比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制。不需要监听在每个元素身上的事件，提升性能</p> <h3 id="说一下图片的懒加载和预加载"><a href="#说一下图片的懒加载和预加载" class="header-anchor">#</a> 说一下图片的懒加载和预加载</h3> <p>预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。<br>
懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。<br>
两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。<br>
懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力</p> <h3 id="js-的-new-操作符做了哪些事情"><a href="#js-的-new-操作符做了哪些事情" class="header-anchor">#</a> JS 的 new 操作符做了哪些事情</h3> <p>new 在执行时会做四件事情:</p> <ol><li><p>在内存中创建一个新的空对象。</p></li> <li><p>让 this 指向这个新的对象。</p></li> <li><p>执行构造函数里面的代码，给这个新对象添加属性和方法。</p></li> <li><p>返回这个新对象(所以构造函数里面不需要 return )</p></li></ol> <h3 id="bind-apply-call-的区别"><a href="#bind-apply-call-的区别" class="header-anchor">#</a> bind，apply，call 的区别</h3> <p><code>call</code> 和 <code>apply</code> 都是为了解决改变 <code>this</code> 的指向。作用都是相同的，只是传参的方式不同。<br>
除了第一个参数外，<code>call</code> 可以接收一个参数列表，<code>apply</code> 只接受一个参数数组<br> <code>bind</code> 和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过<code>bind</code> 实现柯里化</p> <h3 id="clientheight-scrollheight-offsetheight-以及-scrolltop-offsettop-clienttop-的区别"><a href="#clientheight-scrollheight-offsetheight-以及-scrolltop-offsettop-clienttop-的区别" class="header-anchor">#</a> clientHeight,scrollHeight,offsetHeight ,以及 scrollTop, offsetTop,clientTop 的区别？</h3> <p>clientHeight：表示的是可视区域的高度，不包含 border 和滚动条<br>
offsetHeight：表示可视区域的高度，包含了 border 和滚动条<br>
scrollHeight：表示了所有区域的高度，包含了因为滚动被隐藏的部分<br>
clientTop：表示边框 border 的厚度，在未指定的情况下一般为 0<br>
scrollTop：滚动后被隐藏的高度，获取对象相对于由<br>
offsetParent 属性指定的父坐标(css 定位的元素或 body 元素)距离顶端的高度</p> <h3 id="异步加载-js-的方法"><a href="#异步加载-js-的方法" class="header-anchor">#</a> 异步加载 JS 的方法</h3> <p>defer：只支持 IE 如果您的脚本不会改变文档的内容，可将 defer 属性加入到<code>&lt;script&gt;</code>标 签中，以便加快处理文档的速度。因为浏览器知道它将能够安全地读取文档的剩余部分 而不用执行脚本，它将推迟对脚本的解释，直到文档已经显示给用户为止。<br>
async，HTML5 属性仅适用于外部脚本，并且如果在 IE 中，同时存在 defer 和 async，那 么 defer 的优先级比较高，脚本将在页面完成时执行。 创建 script 标签，插入到 DOM 中</p> <p>defer与async的区别是：前者要等到整个页面正常渲染结束，才会执行；后者一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer是“渲染完再执行”，async是“下载完就执行”。另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。</p> <h3 id="ajax-解决浏览器缓存问题"><a href="#ajax-解决浏览器缓存问题" class="header-anchor">#</a> Ajax 解决浏览器缓存问题</h3> <ol><li>在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(&quot;If-Modified-Since&quot;,&quot;0&quot;)。</li> <li>在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;)</li> <li>在 URL 后面加上一个随机数： &quot;fresh=&quot; + Math.random()</li> <li>在 URL 后面加上时间搓：&quot;nowtime=&quot; + new Date().getTime()</li></ol> <h3 id="js-的节流和防抖"><a href="#js-的节流和防抖" class="header-anchor">#</a> JS 的节流和防抖</h3> <p>防抖和节流的作用都是防止函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于<code>wait</code>，防抖的情况下只会调用一次，而节流的 情况会每隔一定时间（参数<code>wait</code>）调用函数
防抖:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 这个是用来获取当前时间戳的</span>
<span class="token keyword">function</span> <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">/**
 * 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行
 *
 * @param  {function} func        回调函数
 * @param  {number}   wait        表示时间窗口的间隔
 * @param  {boolean}  immediate   设置为ture时，是否立即调用函数
 * @return {function}             返回客户调用函数
 */</span>
<span class="token keyword">function</span> <span class="token function">debounce</span> <span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> wait <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">,</span> immediate <span class="token operator">=</span> <span class="token boolean">true</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> timer<span class="token punctuation">,</span> context<span class="token punctuation">,</span> args

  <span class="token comment">// 延迟执行函数</span>
  <span class="token keyword">const</span> <span class="token function-variable function">later</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 延迟函数执行完毕，清空缓存的定时器序号</span>
    timer <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token comment">// 延迟执行的情况下，函数会在延迟函数中执行</span>
    <span class="token comment">// 使用到之前缓存的参数和上下文</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>immediate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
      context <span class="token operator">=</span> args <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span>

  <span class="token comment">// 这里返回的函数是每次实际调用的函数</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>params</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果没有创建延迟执行函数（later），就创建一个</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      timer <span class="token operator">=</span> <span class="token function">later</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token comment">// 如果是立即执行，调用函数</span>
      <span class="token comment">// 否则缓存参数和调用上下文</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>immediate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> params<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        context <span class="token operator">=</span> <span class="token keyword">this</span>
        args <span class="token operator">=</span> params
      <span class="token punctuation">}</span>
    <span class="token comment">// 如果已有延迟执行函数（later），调用的时候清除原来的并重新设定一个</span>
    <span class="token comment">// 这样做延迟函数会重新计时</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>
      timer <span class="token operator">=</span> <span class="token function">later</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>节流:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 / wait
 *
 * @param  {function}   func      回调函数
 * @param  {number}     wait      表示时间窗口的间隔
 * @param  {object}     options   如果想忽略开始函数的的调用，传入{leading: false}。
 *                                如果想忽略结尾函数的调用，传入{trailing: false}
 *                                两者不能共存，否则函数不能执行
 * @return {function}             返回客户调用函数   
 */</span>
_<span class="token punctuation">.</span><span class="token function-variable function">throttle</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> wait<span class="token punctuation">,</span> options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> context<span class="token punctuation">,</span> args<span class="token punctuation">,</span> result<span class="token punctuation">;</span>
    <span class="token keyword">var</span> timeout <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token comment">// 之前的时间戳</span>
    <span class="token keyword">var</span> previous <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果 options 没传则设为空对象</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>options<span class="token punctuation">)</span> options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">// 定时器回调函数</span>
    <span class="token keyword">var</span> <span class="token function-variable function">later</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果设置了 leading，就将 previous 设为 0</span>
      <span class="token comment">// 用于下面函数的第一个 if 判断</span>
      previous <span class="token operator">=</span> options<span class="token punctuation">.</span>leading <span class="token operator">===</span> <span class="token boolean">false</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> _<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 置空一是为了防止内存泄漏，二是为了下面的定时器判断</span>
      timeout <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      result <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timeout<span class="token punctuation">)</span> context <span class="token operator">=</span> args <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 获得当前时间戳</span>
      <span class="token keyword">var</span> now <span class="token operator">=</span> _<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 首次进入前者肯定为 true</span>
	  <span class="token comment">// 如果需要第一次不执行函数</span>
	  <span class="token comment">// 就将上次时间戳设为当前的</span>
      <span class="token comment">// 这样在接下来计算 remaining 的值时会大于0</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>previous <span class="token operator">&amp;&amp;</span> options<span class="token punctuation">.</span>leading <span class="token operator">===</span> <span class="token boolean">false</span><span class="token punctuation">)</span> previous <span class="token operator">=</span> now<span class="token punctuation">;</span>
      <span class="token comment">// 计算剩余时间</span>
      <span class="token keyword">var</span> remaining <span class="token operator">=</span> wait <span class="token operator">-</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> previous<span class="token punctuation">)</span><span class="token punctuation">;</span>
      context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
      args <span class="token operator">=</span> arguments<span class="token punctuation">;</span>
      <span class="token comment">// 如果当前调用已经大于上次调用时间 + wait</span>
      <span class="token comment">// 或者用户手动调了时间</span>
 	  <span class="token comment">// 如果设置了 trailing，只会进入这个条件</span>
	  <span class="token comment">// 如果没有设置 leading，那么第一次会进入这个条件</span>
	  <span class="token comment">// 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 if 条件了</span>
	  <span class="token comment">// 其实还是会进入的，因为定时器的延时</span>
	  <span class="token comment">// 并不是准确的时间，很可能你设置了2秒</span>
	  <span class="token comment">// 但是他需要2.2秒才触发，这时候就会进入这个条件</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>remaining <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> remaining <span class="token operator">&gt;</span> wait<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果存在定时器就清理掉否则会调用二次回调</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
          timeout <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        previous <span class="token operator">=</span> now<span class="token punctuation">;</span>
        result <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timeout<span class="token punctuation">)</span> context <span class="token operator">=</span> args <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timeout <span class="token operator">&amp;&amp;</span> options<span class="token punctuation">.</span>trailing <span class="token operator">!==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 判断是否设置了定时器和 trailing</span>
	    <span class="token comment">// 没有的话就开启一个定时器</span>
        <span class="token comment">// 并且不能不能同时设置 leading 和 trailing</span>
        timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>later<span class="token punctuation">,</span> remaining<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="对象深度克隆的简单实现"><a href="#对象深度克隆的简单实现" class="header-anchor">#</a> 对象深度克隆的简单实现</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">deepClone</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
    <span class="token keyword">var</span> newObj<span class="token operator">=</span> obj <span class="token keyword">instanceof</span> <span class="token class-name">Array</span> <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> 
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> item <span class="token keyword">in</span> obj<span class="token punctuation">)</span><span class="token punctuation">{</span> 
        <span class="token keyword">var</span> temple<span class="token operator">=</span> <span class="token keyword">typeof</span> obj<span class="token punctuation">[</span>item<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'object'</span> <span class="token operator">?</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>item<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">:</span> obj<span class="token punctuation">[</span>item<span class="token punctuation">]</span><span class="token punctuation">;</span> 
        newObj<span class="token punctuation">[</span>item<span class="token punctuation">]</span> <span class="token operator">=</span> temple<span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
        <span class="token keyword">return</span> newObj<span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
</code></pre></div><h3 id="实现一个-once-函数-传入函数参数只执行一次"><a href="#实现一个-once-函数-传入函数参数只执行一次" class="header-anchor">#</a> 实现一个 once 函数，传入函数参数只执行一次</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">ones</span><span class="token punctuation">(</span><span class="token parameter">func</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
    <span class="token keyword">var</span> tag<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span> 
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
        <span class="token keyword">if</span><span class="token punctuation">(</span>tag<span class="token operator">==</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
            <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span> 
            tag<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span> 
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token keyword">undefined</span> 
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="settimeout、setinterval-和-requestanimationframe-之间的区别"><a href="#settimeout、setinterval-和-requestanimationframe-之间的区别" class="header-anchor">#</a> setTimeout、setInterval 和 requestAnimationFrame 之间的区别</h3> <p>requestAnimationFrame 不需要设置时间间隔大多数电脑显示器的刷新频率是 60Hz，大概相当于每秒钟重绘 60 次。大多数浏览器都 会对重绘操作加以限制，不超过显示器的重绘频率，因为即使超过那个频率用户体验也 不会有提升。因此，最平滑动画的最佳循环间隔是 1000ms/60，约等于 16.6ms。 RAF 采用的是系统时间间隔，不会因为前面的任务，不会影响 RAF，但是如果前面的 任务多的话会响应 setTimeout 和 setInterval 真正运行时的时间间隔。</p> <p>特点：</p> <ol><li>requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回 流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率。</li> <li>在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然 就意味着更少的 CPU、GPU 和内存使用量</li> <li>requestAnimationFrame 是由浏览器专门为动画提供的 API，在运行时浏览器会自动 优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了 CPU 开销</li></ol> <h3 id="用-settimeout-来实现-setinterval"><a href="#用-settimeout-来实现-setinterval" class="header-anchor">#</a> 用 setTimeout 来实现 setInterval</h3> <ol><li>setInterval对自己调用的代码是否报错漠不关心。即使调用的代码报错了，它依然会持续的调用下去</li> <li>setInterval无视网络延迟。在使用ajax轮询服务器是否有新数据时，必定会有一些人会使用setInterval，然而无论网络状况如何，它都会去一遍又一遍的发送请求，如果网络状况不良，一个请求发出，还没有返回结果，它会坚持不懈的继续发送请求，最后导致的结果就是请求堆积。</li> <li>setInterval并不定时。如果它调用的代码执行的时间小于定时的时间，它会跳过调用，这就导致无法按照你需要的执行次数或无法得到你想要的结果。</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 第一种</span>
<span class="token keyword">let</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'执行SI'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">setTimeToInterval</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> delay<span class="token punctuation">,</span> times</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> timer<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>times<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>
    timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token function">setTimeToInterval</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> delay<span class="token punctuation">,</span> <span class="token operator">--</span>times<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">setTimeToInterval</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token comment">// 第二种</span>
<span class="token keyword">function</span> <span class="token function">mySetInterval</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> delay<span class="token punctuation">,</span> times</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        times<span class="token operator">--</span>
        timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> delay<span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>times <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">mySetInterval</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="js-怎么控制一次加载一张图片-加载完后再加载下一张"><a href="#js-怎么控制一次加载一张图片-加载完后再加载下一张" class="header-anchor">#</a> JS 怎么控制一次加载一张图片，加载完后再加载下一张</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">preloadImg</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">src</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> img <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        img<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        img<span class="token punctuation">.</span>src <span class="token operator">=</span> src<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> preloadList <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token string">'./pic-1.png'</span><span class="token punctuation">,</span>
    <span class="token string">'./pic-2.png'</span><span class="token punctuation">,</span>
    <span class="token string">'./pic-3.png'</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>


Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span>preloadList<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">src</span> <span class="token operator">=&gt;</span> <span class="token function">preloadImg</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="代码的执行顺序"><a href="#代码的执行顺序" class="header-anchor">#</a> 代码的执行顺序</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> 
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 2 6 5 3 4 1</span>
</code></pre></div><h3 id="js-判断类型"><a href="#js-判断类型" class="header-anchor">#</a> JS 判断类型</h3> <p>判断方法：typeof()，instanceof，Object.prototype.toString.call()等</p> <h3 id="数组去重"><a href="#数组去重" class="header-anchor">#</a> 数组去重</h3> <ol><li>indexOf 循环去重</li> <li>ES6 Set 去重；Array.from(new Set(array))</li> <li>Object 键值对去重；把数组的值存成 Object 的 key 值，比如 Object[value1] = true，
在判断另一个值的时候，如果 Object[value2]存在的话，就说明该值是重复的。</li></ol> <h3 id="手写实现api部分"><a href="#手写实现api部分" class="header-anchor">#</a> 手写实现api部分</h3> <p>call bind apply</p> <h3 id="知道-private-和-public-吗"><a href="#知道-private-和-public-吗" class="header-anchor">#</a> 知道 private 和 public 吗</h3> <p>public：public 表明该数据成员、成员函数是对所有用户开放的，所有用户都可以直接进行调用
private：private 表示私有，私有的意思就是除了 class 自己之外，任何人都不可以直接使用</p> <h3 id="es6-的常用"><a href="#es6-的常用" class="header-anchor">#</a> es6 的常用</h3> <p>promise，await/async，let、const、块级作用域、箭头函数</p> <h3 id="eventloop"><a href="#eventloop" class="header-anchor">#</a> EventLoop</h3> <ul><li>执行同步代码，这属于宏任务</li> <li>执行栈为空，查询是否有微任务需要执行</li> <li>执行所有微任务</li> <li>必要的话渲染 <code>UI</code></li> <li>然后开始下一轮 <code>Event loop</code>，执行宏任务中的异步代码</li></ul> <blockquote><p>通过上述的 <code>Event loop</code> 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 <code>DOM</code> 的话，为了更快的 界面响应，我们可以把操作 <code>DOM</code> 放入微任务中</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script start'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Promise'</span><span class="token punctuation">)</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script end'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTimeout</span>
</code></pre></div><h2 id="服务端-浏览器"><a href="#服务端-浏览器" class="header-anchor">#</a> 服务端&amp;浏览器</h2> <h3 id="什么是跨域-为什么浏览器要使用同源策略-你有几种方式可以解决跨域问题-了解预检请求嘛"><a href="#什么是跨域-为什么浏览器要使用同源策略-你有几种方式可以解决跨域问题-了解预检请求嘛" class="header-anchor">#</a> 什么是跨域？为什么浏览器要使用同源策略？你有几种方式可以解决跨域问题？了解预检请求嘛？</h3> <ul><li>因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，<code>Ajax</code> 请求会失败。</li> <li>那么是出于什么安全考虑才会引入这种机制呢？ 其实主要是用来防止 <code>CSRF</code> 攻击的。简单点说，<code>CSRF</code> 攻击是利用用户的登录态发起恶意请求。</li> <li>也就是说，没有同源策略的情况下，<code>A</code> 网站可以被任意其他来源的 <code>Ajax</code> 访问到内容。如果你当前 <code>A</code> 网站还存在登录态，那么对方就可以通过 <code>Ajax</code> 获得你的任何信息。当然跨域并不能完全阻止 <code>CSRF</code>。</li></ul> <h4 id="jsonp"><a href="#jsonp" class="header-anchor">#</a> JSONP</h4> <p><code>JSONP</code> 的原理很简单，就是利用 <code>标签没有跨域限制的漏洞。通过</code>标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
    <span class="token keyword">function</span> <span class="token function">jsonp</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>  
</code></pre></div><h4 id="cors"><a href="#cors" class="header-anchor">#</a> CORS</h4> <ul><li><code>CORS</code> 需要浏览器和后端同时支持。<code>IE 8</code> 和 <code>9</code> 需要通过 <code>XDomainRequest</code> 来实现。</li> <li>浏览器会自动进行 <code>CORS</code> 通信，实现 <code>CORS</code> 通信的关键是后端。只要后端实现了 <code>CORS</code>，就实现了跨域。</li> <li>服务端设置 <code>Access-Control-Allow-Origin</code> 就可以开启 <code>CORS</code>。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。 虽然设置 <code>CORS</code>和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求。</li></ul> <p><strong>简单请求</strong></p> <blockquote><p>以 <code>Ajax</code> 为例，当满足以下条件时，会触发简单请求</p></blockquote> <ol><li>使用下列方法之一：</li></ol> <ul><li><code>GET</code></li> <li><code>HEAD</code></li> <li><code>POST</code></li></ul> <ol><li><code>Content-Type</code> 的值仅限于下列三者之一：</li></ol> <ul><li>text/plain</li> <li><code>multipart/form-data</code></li> <li><code>application/x-www-form-urlencoded</code></li></ul> <blockquote><p>请求中的任意 <code>XMLHttpRequestUpload</code> 对象均没有注册任何事件监听器； <code>XMLHttpRequestUpload</code> 对象可以使用 <code>XMLHttpRequest.upload</code> 属性访问</p></blockquote> <p><strong>复杂请求</strong></p> <blockquote><p>对于复杂请求来说，首先会发起一个预检请求，该请求是 <code>option</code> 方法的，通过该请求来知道服务端是否允许跨域请求。</p></blockquote> <p>对于预检请求来说，如果你使用过 <code>Node</code> 来设置 <code>CORS</code> 的话，可能会遇到过这么一个坑。</p> <p>以下以 <code>express</code>框架举例</p> <div class="language-js extra-class"><pre class="language-js"><code>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  res<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Allow-Origin'</span><span class="token punctuation">,</span> <span class="token string">'*'</span><span class="token punctuation">)</span>
  res<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Allow-Methods'</span><span class="token punctuation">,</span> <span class="token string">'PUT, GET, POST, DELETE, OPTIONS'</span><span class="token punctuation">)</span>
  res<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span>
    <span class="token string">'Access-Control-Allow-Headers'</span><span class="token punctuation">,</span>
    <span class="token string">'Origin, X-Requested-With, Content-Type, Accept, Authorization, Access-Control-Allow-Credentials'</span>
  <span class="token punctuation">)</span>
  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>该请求会验证你的 <code>Authorization</code> 字段，没有的话就会报错。</li> <li>当前端发起了复杂请求后，你会发现就算你代码是正确的，返回结果也永远是报错的。因为预检请求也会进入回调中，也会触发 <code>next</code> 方法，因为预检请求并不包含 <code>Authorization</code> 字段，所以服务端会报错。</li></ul> <blockquote><p>想解决这个问题很简单，只需要在回调中过滤 <code>option</code> 方法即可</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code>res<span class="token punctuation">.</span>statusCode <span class="token operator">=</span> <span class="token number">204</span>
res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Content-Length'</span><span class="token punctuation">,</span> <span class="token string">'0'</span><span class="token punctuation">)</span>
res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="document-domain"><a href="#document-domain" class="header-anchor">#</a> document.domain</h4> <ul><li>该方式只能用于主域名相同的情况下，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 适用于该方式。</li> <li>只需要给页面添加 <code>document.domain = 'test.com'</code> 表示主域名都相同就可以实现跨域</li></ul> <h4 id="postmessage"><a href="#postmessage" class="header-anchor">#</a> postMessage</h4> <blockquote><p>这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 发送消息端</span>
window<span class="token punctuation">.</span>parent<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> <span class="token string">'http://test.com'</span><span class="token punctuation">)</span>
<span class="token comment">// 接收消息端</span>
<span class="token keyword">var</span> mc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
mc<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> <span class="token parameter">event</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> origin <span class="token operator">=</span> event<span class="token punctuation">.</span>origin <span class="token operator">||</span> event<span class="token punctuation">.</span>originalEvent<span class="token punctuation">.</span>origin
  <span class="token keyword">if</span> <span class="token punctuation">(</span>origin <span class="token operator">===</span> <span class="token string">'http://test.com'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'验证通过'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="http和https"><a href="#http和https" class="header-anchor">#</a> http和https</h3> <p>http是超文本传输协议 传输的数据都是未加密的明文传输http协议端口 80 是无状态的连接
https是具有安全性身份认证的ssl加密传输协议 https端口 443 需要ca证书</p> <p>tcp和udp的区别
tcp是面向连接的，提供可靠的服务</p> <h3 id="从输入url到获取页面过程"><a href="#从输入url到获取页面过程" class="header-anchor">#</a> 从输入url到获取页面过程</h3> <p>输入 url 后，首先需要找到这个 url 域名的服务器 ip,为了寻找这个 ip，浏览器首先会寻找缓存，查看缓存中是否有记录，缓存的查找记录为：浏览器缓存-》系统缓存-》路由器缓存，缓存中没有则查找系统的 hosts 文件中是否有记录，如果没有则查询 DNS 服务器，得到服务器的 ip 地址后，浏览器根据这个 ip 以及相应的端口号，构造一个 http 请求，这个请求报文会包括这次请求的信息，主要是请求方法，请求说明和请求附带的数据，并将这个 http 请求封装在一个 tcp 包中，这个 tcp 包会依次经过传输层，网络层， 数据链路层，物理层到达服务器，服务器解析这个请求来作出响应，返回相应的 html 给浏览器，因为 html 是一个树形结构，浏览器根据这个 html 来构建 DOM 树，在 dom 树的构建过程中如果遇到 JS 脚本和外部 JS 连接，则会停止构建 DOM 树来执行和下载相应的代码，这会造成阻塞，这就是为什么推荐 JS 代码应该放在 html 代码的后面，之后根据外部样式，内部样式，内联样式构建一个 CSS 对象模型树 CSSOM 树，构建完成后和 DOM 树合并为渲染树，这里主要做的是排除非视觉节点，比如 script，meta 标签和排除 display 为 none 的节点，之后进行布局，布局主要是确定各个元素的位置和尺寸，之后是渲染页面，因为html文件中会含有图片，视频，音频等资源，在解析 DOM 的过程中，遇到这些都会进行并行下载，浏览器对每个域的并行下载数量有一定的限制，一般是 4-6 个，当然在这些所有的请求中我们还需要关注的就是缓存，缓存一般通过 Cache-Control、Last-Modify、Expires 等首部字段控制。 Cache-Control 和 Expires 的区别 在于 Cache-Control 使用相对时间，Expires 使用的是基于服务器端的绝对时间，因为存在时差问题，一般采用 Cache-Control，在请求这些有设置了缓存的数据时，会先查看是否过期，如果没有过期则直接使用本地缓存，过期则请求并在服务器校验文件是否修改，如果上一次响应设置了 ETag 值会在这次请求的时候作为 If-None-Match 的值交给服务器校验，如果一致，继续校验 Last-Modified，没有设置 ETag 则直接验证 Last-Modified，再决定是否返回 304</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.bb29d11c.js" defer></script><script src="/assets/js/2.571a1620.js" defer></script><script src="/assets/js/10.0a312df9.js" defer></script>
  </body>
</html>
